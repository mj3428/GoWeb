# 力扣刷题笔记
1. 题3，for range循环其实是遍历一个映射，所以大多数的for range会补上一个_符号（空白标识符blank identifer），用于忽略键值。
`for _, i := range map{}map值或者其他可迭代变量`且在map不声明的情况，循环字符串到时候，i其实是一个字节byte类型，一般为ascii码。
另外,你也可以在初声明时，[256]int{},这里256其实也是字符对应byte后的ascii码，最大为256，其实就是隐含表示映射为[string]int{}。  
2. 题4，`make(slice, len, cap)`make创建初始slice，后面为长度和容量，而容量cap是指数组left的起始到数组末尾的长度值，不是下标取值处。  
3. 题6，bytes.buffer{}其实是创建一个纯字符串，可以用于拼接，速度比slice快很多。也比strings.Join快很多。  
4. 题7，涉及计算，用math包，math.MaxInt32还能限制int的字节存储设置，来查看内存的溢出。
5. 题8，当字符串转换成byte之后
```
	import (
		"fmt"
	)

	func main() {
		//s := []string{"abcd"}
		s := "01234a 56789"
		for _, i := range []byte(s){
		    i -= '0'//这里‘0’其实ASCII码0的其实位置,相减之后空格从32变为240
		    fmt.Println(int(i))
		}
	}
	输出结果：0 1 2 3 4 49 240 5 6 7 8 9
```
6. 题8，且在适当时要会使用switch与case结合。
7. 题11，少用穷举法！！为什么math包有float64而没有int，因为float复杂float64类型要处理infinity和not-a-number这种值，而他们的
处理非常复杂，一般用户没有能力。golang让你自己写int的比较大小，不要偷懒。
8. 正常先排序，然后2个穷举，比3个穷举快，另外switch case default还是没有掌握好，要学好。不然纯for if语句还是不很好看。
9. 题22，递归：  
	-  递归就是方法里调用自身
	-  在使用递增归策略时，必须有一个明确的递归结束条件，称为递归出口
	-  递归算法解题通常显得很简洁，但递归算法解题的运行效率较低。所以一般不提倡用递归算法设计程序
	-  递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等，所以一般不提倡用递归算法设计程序
